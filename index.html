<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Martial Peak — Reader</title>

  <!-- Markdown renderer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- Noto Serif & Noto Sans (matched serif/sans pair) loaded from Google Fonts.
    We request weights 300/400/700 and use display=swap to avoid blocking render. -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300;400;700&family=Noto+Sans:wght@300;400;700&display=swap" rel="stylesheet">

  <style>
    /* THEME TOKENS */
    :root[data-theme="light"] {
  --bg: #f4ecd8;           /* sepia background, less yellow */
  --fg: #5b4636;           /* readable brown text */
  --muted: #a58c6f;        /* muted brown */
  --primary: #b5853e;      /* warm accent */
  --surface: #f7f3e6;      /* lighter sepia for surfaces, less yellow */
  --border: #e0d6c3;       /* soft border */
  --link: #a86b32;         /* brownish link */
    }
    :root[data-theme="dark"] {
  --bg: #18222d;           /* deep blue-gray background */
  --fg: #c7d4e6;           /* cool light blue text */
  --muted: #6b7a8f;        /* muted blue-gray */
  --primary: #4f8cc9;      /* blue accent */
  --surface: #223042;      /* lighter blue-gray for surfaces */
  --border: #2c3a4d;       /* soft blue border */
  --link: #7ec3fa;         /* bright blue link */
    }
    
    /* ====== Layout tokens (tweak these to change spacing/sizes globally) ======
       --header-h: height of the top header
       --settings-rail-w: width of the right-side settings rail
       --icon-btn-size: square hit area for small header/rail buttons (do NOT confuse with glyph size)
       --icon-glyph-size: visual size of the SVG icon inside the button
    */
    :root { 
      --header-h: 56px; /* adjust if you like */
      --settings-rail-w: 72px; /* change to widen/narrow the settings rail in one place */
      --icon-btn-size: 42px;   /* hit/touch area for .icon-btn */
      --icon-glyph-size: 20px; /* visual size of the SVG glyph inside the button */
  /* reader-only font family (serif) */
  --reader-font-family: Georgia, 'Times New Roman', Times, serif;
    }
    header.site-header { min-height: var(--header-h); }

    :root{
      --content-w: 72ch; /* comfortable line length: ~70–75 characters */
    }

    


    /* LAYOUT */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    /* global hidden helper (keeps layout space like your .nav rule) */
    .hidden { visibility: hidden; }


    .app {
      display: grid;
      grid-template-columns: 280px 1fr;
      height: 100vh;
      transition: grid-template-columns .2s ease;
    }
    /* desktop collapse state */
    body.sidebar-collapsed .app { grid-template-columns: 0 1fr; }
    /* you already have: body.sidebar-collapsed .app { grid-template-columns: 0 1fr; } */
    body.sidebar-collapsed .sidebar {
      width: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
      border: 0 !important;
      overflow: hidden !important;
    }
    body.sidebar-collapsed .sidebar * { display: none !important; } /* hide children so nothing paints */


    /* SIDEBAR */
    .sidebar {
      background: var(--surface);
      border-right: 1px solid var(--border);
      padding: 12px;
  overflow-y: auto;
  /* Always allow scrolling on hover, no click needed */
      position: relative;
  z-index: 1100; /* above the overlay */
    }

    .sidebar h1{
    text-align:center;
    margin: 6px 0 10px;
    font-size: 18px;
    font-weight: 700;
    }

    .chapter-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .chapter-list a {
      display: block;
      padding: 8px 10px;
      border-radius: 8px;
      color: var(--fg);
      text-decoration: none;
      border: 1px solid transparent;
    }
    .chapter-list a:hover {
      background: rgba(127,127,127,.08);
      border-color: var(--border);
    }
    .chapter-list a.active {
      background: rgba(99,102,241,0.12);
      border-color: var(--primary);
      color: var(--primary);
      font-weight: 600;
    }

    /* keep the layout inside the viewport on every device */
    html, body { overflow-x: hidden; }

    /* prevent long titles from stretching the header */
    #chapterTitle {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* keep chapter content within the screen */
    article#article {
      max-width: 100%;
      overflow-wrap: anywhere;   /* handles super-long words/links */
      word-break: break-word;
    }

    /* make wide content responsive */
    article#article img,
    article#article table,
    article#article iframe {
      max-width: 100%;
      height: auto;
    }


    /* CONTENT */
    /* Let the whole right column scroll so the scrollbar is at the viewport edge */
    /* Right column no longer scrolls itself */
    .content {
      display: flex;
      flex-direction: column;
      min-width: 0;
      min-height: 0;
  overflow: visible;                /* allow scrolling if child overflows */
    }

        /* New: inner scroller so the track sits at far right,
      and does NOT run behind the sticky header */
    .scroller {
      flex: 1 1 auto;
      min-height: 0;
  overflow-y: auto;                 /* always allow vertical scrolling */
      scrollbar-gutter: stable;         /* keeps a gutter so layout doesn’t jump */
      scroll-padding-top: var(--header-h);  /* anchors don’t hide under header */
    }

    header.site-header {
      position: sticky;
      top: 0;
      z-index: 1002;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      height: var(--header-h);     /* ← explicit height */
      background: var(--surface);
      border-bottom: 1px solid var(--border);
    }

    @media (min-width: 901px) {
      .site-header.hide-on-scroll {
        left: 280px; /* sidebar width */
        width: calc(100% - 280px);
      }
      body.sidebar-collapsed .site-header.hide-on-scroll {
        left: 0;
        width: 100%;
      }
    }
    

    /* BUTTONS (theme + arrows share the same style) */
    /* shared style for theme + arrow buttons */
    /* Small circular/square icon buttons used in the header and settings rail.
       Important: these define the hit area (touch target). The actual icon inside
       is sized via --icon-glyph-size so you can make the glyph larger/smaller
       independently of touch size for consistent UX.
    */
    .icon-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      width: var(--icon-btn-size);
      height: var(--icon-btn-size);
      display: inline-grid;
      place-items: center;
      cursor: pointer;
      color: var(--fg);
      text-decoration: none;
  font-size: 20px;
  line-height: 1;
      padding: 0;
    }

  /* Remove all button states: no :active, :focus, :hover, or toggled styles. */

    @media (max-width: 900px) {
      /* slightly larger touch targets on phones */
    }

    /* visual size of the svg glyph inside the button; keep glyph smaller than hit area */
    .icon-btn svg { width: var(--icon-glyph-size); height: var(--icon-glyph-size); display: block; }
  /* make the font-cycle button itself use the active reader font so the "F" previews the selection */
  #s-fontCycle { font-family: var(--reader-font-family, Georgia, 'Times New Roman', Times, serif); font-weight: 300; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  /* weight-toggle icon: use current color for fill so it matches other icons */
  #s-weightToggle svg rect { fill: currentColor; }

    /* Settings sidebar (right) */
    .settings-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      width: var(--settings-rail-w);
      height: 100vh;
      background: var(--surface);
      border-left: 1px solid var(--border);
      box-shadow: -2px 0 12px rgba(0,0,0,0.08);
      display: flex;
      align-items: flex-start;    /* align content to the top */
      justify-content: flex-start;
      z-index: 1100;              /* match left sidebar stacking for consistent overlay ordering */
      transform: translateX(100%);
      transition: transform .25s cubic-bezier(.2,.8,.2,1);
      will-change: transform;     /* hint for smoother animation */
    }
    .settings-sidebar.open { transform: translateX(0); }
    /* Desktop: respect body.settings-open to reveal a compact right rail */
    @media (min-width: 901px) {
      body.settings-open .settings-sidebar { transform: translateX(0); }
      /* reserve a small right margin when settings rail is open so content doesn't shift awkwardly */
  body.settings-open .app { margin-right: var(--settings-rail-w); transition: margin-right .25s cubic-bezier(.2,.8,.2,1); }
    }
    /* place controls centered horizontally and aligned vertically to the header (same level as the cog) */
    .settings-inner {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    /* position first button so its center lines up with the header center.
      42px is the .icon-btn height; adjust if you change button size
      add a small nudge so the control aligns with the cog distance from the top edge */
    padding-top: 17px;
      align-items: center; /* center horizontally */
      box-sizing: border-box;
    }
  /* reuse icon-btn visuals for cog button; push it to the far right of the tools */
  #cogBtn { display:inline-grid; place-items:center; margin-left: auto; align-self:center; }

    @media (max-width: 900px) {
      .icon-btn svg { width: 22px; height: 22px; }
    }


  /* No hover effect. */

    /* HAMBURGER */
    .menu {
      background: none;
      border: none;
      display: inline-flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px;
      cursor: pointer;
    }
    .menu span {
      width: 24px;
      height: 2.5px;
      background: var(--fg);
      border-radius: 2px;
      transition: background .2s ease;
    }

    .tools {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    main.reader {
      flex: 0 0 auto;
      overflow: visible;
      box-sizing: border-box;
      max-width: var(--content-w);                  /* your readable width */
      margin: 0 auto;
      padding: 0px 16px 40px;           /* small top pad so text doesn’t kiss border */
    }
    @media (min-width: 901px){
      main.reader{ padding: 0 24px 56px; }
    }


    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 10px 0 18px;
    }

  article#article { font-size: 18px; }
  article#article { font-family: var(--reader-font-family, Georgia, 'Times New Roman', Times, serif); font-weight: 300; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    article#article h1, article#article h2, article#article h3 {
      line-height: 1.25;
      margin-top: 1.4em;
    }
    article#article p { margin: 1em 0; }
    article#article hr {
      border: 0;
      border-top: 1px solid var(--border);
      margin: 2rem 0;
    }
    article#article a { color: var(--link); }

    /* OVERLAY for mobile only */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.45);
      display: none;
      z-index: 1095; /* below sidebars (1100) */
    }
    .overlay.show { display: block; }

    /* MOBILE */
    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; }          /* sidebar column hidden */

      .sidebar{
        position: fixed;
        left: 0; top: 0; bottom: 0;
        transform: translateX(-100%);
        transition: transform .25s ease;
        width: min(85vw, 320px);
        z-index: 1100;                               /* above page header */
        background: var(--surface);
        border-right: 1px solid var(--border);
        overflow-y: auto;                             /* drawer scrolls */
        padding-top: 0px;  /* space from top */
      }
      .sidebar.open{ transform: translateX(0); }

      /* Simple title — centered, no sticky */
      .sidebar h1{
        margin: 0 0 12px;
        padding: 0 16px;
        text-align: center;
        font-size: 18px;
        font-weight: 700;
      }

      /* List sits right under the title */
      .sidebar ul{
        margin: 0;
        padding: 0;
      }

      /* overlay sits below drawer but above content */
      .overlay{ z-index: 1090; }
  /* settings sidebar mobile alignment */
  .settings-sidebar { top: 0; padding-top: 0px; z-index: 1100; }
  .settings-sidebar.open { transform: translateX(0); }
    }


  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" id="sidebar">
      <h1>Martial Peak</h1>
      <ul class="chapter-list" id="chaptersList"></ul>
    </aside>

    <div class="content">
      <!--
        Header: contains the hamburger menu, current chapter title, and header tools.
        - #menuBtn toggles the left chapter drawer (mobile) or collapses the sidebar (desktop)
        - #chapterTitle shows the current chapter's title
        - .tools holds inline header controls (arrows + cog). Most controls are shared
          with the right settings rail to keep behavior consistent.
      -->
      <header class="site-header">
        <button class="menu" id="menuBtn" aria-label="Menu">
          <span></span><span></span><span></span>
        </button>
        <strong id="chapterTitle">Loading…</strong>
  <div class="tools">
          <!-- font and theme controls moved into the settings sidebar on the right -->
          <!-- top nav arrows (these are buttons for consistent semantics/accessibility) -->
          <button id="prevTop" class="icon-btn hidden" aria-label="Previous">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <button id="nextTop" class="icon-btn hidden" aria-label="Next">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </button>
          <button id="cogBtn" class="icon-btn" title="Settings" aria-label="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h.09A1.65 1.65 0 0 0 11 3.09V3a2 2 0 0 1 4 0v.09c.38.16.7.46 1 1.51a1.65 1.65 0 0 0 1.82.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82c.16.38.46.7 1.51 1H21a2 2 0 0 1 0 4h-.09c-.16.38-.46.7-1.51 1z"></path></svg>
          </button>
        </div>
      </header>

      <div class="scroller">
        <main class="reader">
          <nav class="nav" id="topNav" style="display:none;"></nav> <!-- kept for structure -->
          <article id="article"></article>
          <nav class="nav" id="bottomNav">
            <button id="prevBottom" class="icon-btn hidden" aria-label="Previous">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polyline points="15 18 9 12 15 6"></polyline>
              </svg>
            </button>
            <button id="nextBottom" class="icon-btn hidden" aria-label="Next">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polyline points="9 18 15 12 9 6"></polyline>
              </svg>
            </button>
          </nav>
        </main>
      </div>
    </div>
  </div>
  <aside class="settings-sidebar" id="settingsSidebar" aria-hidden="true">
    <!--
      Right settings rail: compact vertical controls for font + theme.
      - Sits off-canvas on mobile and as a compact rail on desktop when body.settings-open
      - Buttons here invoke the same handlers as header controls (reuse behavior)
    -->
    <div class="settings-inner" role="menu" aria-label="Settings">
      <button id="s-themeBtn" class="icon-btn" title="Toggle theme" aria-label="Toggle theme">🌓</button>
  <button id="s-fontInc" class="icon-btn" title="Increase font size" aria-label="Increase font size">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
      </button>
      <button id="s-fontDec" class="icon-btn" title="Decrease font size" aria-label="Decrease font size">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
      </button>
      <!-- Cycle reader font family: Droid Serif ↔ Helvetica -->
      <button id="s-fontCycle" class="icon-btn" title="Cycle font family" aria-label="Cycle font family">F</button>
      <!-- Toggle font weight (thin/normal) -->
      <button id="s-weightToggle" class="icon-btn" title="Toggle font weight" aria-label="Toggle font weight">
        <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" focusable="false">
          <rect x="4" y="3" width="2" height="18" rx="1" />
          <rect x="9" y="3" width="3" height="18" rx="1" />
          <rect x="15" y="3" width="4" height="18" rx="1" />
        </svg>
      </button>

  <!-- Content-width controls: narrow / widen readable column -->
      <button id="s-contentDec" class="icon-btn" title="Narrow column" aria-label="Narrow column">M+</button>
      <button id="s-contentInc" class="icon-btn" title="Widen column" aria-label="Widen column">M−</button>
      </div>
  
  </aside>

  <div class="overlay" id="overlay"></div>

  <script>
  // ====== Small runtime guide ======
  // This script wires UI controls (menu, cog, font/theme, navigation) to shared helper
  // functions. Key persisted keys in localStorage are:
  //  - mp_theme: 'light' | 'dark'
  //  - mp_fontsize: number (px)

  // --- Theme ---
    function setTheme(mode) {
      document.documentElement.setAttribute('data-theme', mode);
      localStorage.setItem('mp_theme', mode);
      // update any theme buttons if present (header or sidebar)
      const headerThemeBtn = document.getElementById('themeBtn');
      const sidebarThemeBtn = document.getElementById('s-themeBtn');
      const label = (mode === 'dark') ? '☀️' : '🌙';
      if (headerThemeBtn) headerThemeBtn.textContent = label;
      if (sidebarThemeBtn) sidebarThemeBtn.textContent = label;
    }
    setTheme(localStorage.getItem('mp_theme') || 'light');

  // Font size controls
  // Note: There are two places for font controls — header (optional) and settings rail.
  // We wire both to the same handlers so behavior is identical.
  const fontInc = document.getElementById('fontInc');
  const fontDec = document.getElementById('fontDec');
  const sFontInc = document.getElementById('s-fontInc');
  const sFontDec = document.getElementById('s-fontDec');
  const article = document.getElementById('article');
    function getFontSize() {
      return parseFloat(window.getComputedStyle(article).fontSize);
    }
    function setFontSize(size) {
      article.style.fontSize = size + 'px';
      localStorage.setItem('mp_fontsize', size);
    }
    if (fontInc) {
      fontInc.addEventListener('click', () => {
        setFontSize(Math.min(getFontSize() + 2, 36));
      });
    }
    if (fontDec) {
      fontDec.addEventListener('click', () => {
        setFontSize(Math.max(getFontSize() - 2, 12));
      });
    }
  if (sFontInc) sFontInc.addEventListener('click', () => setFontSize(Math.min(getFontSize() + 2, 36)));
  if (sFontDec) sFontDec.addEventListener('click', () => setFontSize(Math.max(getFontSize() - 2, 12)));
    // Load saved font size
    const savedFont = localStorage.getItem('mp_fontsize');
    if (savedFont) setFontSize(parseFloat(savedFont));
    const headerThemeBtn = document.getElementById('themeBtn');
    if (headerThemeBtn) headerThemeBtn.addEventListener('click', () => {
      setTheme((localStorage.getItem('mp_theme') || 'light') === 'light' ? 'dark' : 'light');
    });

  // --- Reader font family cycling ---
  const sFontCycle = document.getElementById('s-fontCycle');
  const READER_FONTS = [
    { id: 'noto-serif', name: 'Noto Serif', css: "'Noto Serif', serif" },
    { id: 'noto-sans', name: 'Noto Sans', css: "'Noto Sans', sans-serif" }
  ];
  const DEFAULT_READER_ID = 'noto-serif';
  function applyReaderFontById(id) {
    const f = READER_FONTS.find(x => x.id === id) || READER_FONTS[0];
    document.documentElement.style.setProperty('--reader-font-family', f.css);
    localStorage.setItem('mp_readerFont', f.id);
    const lbl = document.getElementById('s-contentLabel');
    if (lbl) lbl.textContent = f.name + ' • ' + getContentWCh() + 'ch';
  }
  function cycleReaderFont() {
    const curId = localStorage.getItem('mp_readerFont') || DEFAULT_READER_ID;
    const idx = Math.max(0, READER_FONTS.findIndex(f => f.id === curId));
    const next = READER_FONTS[(idx + 1) % READER_FONTS.length];
    applyReaderFontById(next.id);
  }
  if (sFontCycle) sFontCycle.addEventListener('click', cycleReaderFont);
  // Restore saved reader font on load (use id-based storage)
  const savedReaderFontId = localStorage.getItem('mp_readerFont');
  if (savedReaderFontId) applyReaderFontById(savedReaderFontId);
  else applyReaderFontById(DEFAULT_READER_ID);

  // --- Reader font weight toggle (300 <-> 400) ---
  const sWeightToggle = document.getElementById('s-weightToggle');
  function applyReaderWeight(w) {
    // apply weight to the article and preview button via inline styles to override computed styles
    document.documentElement.style.setProperty('--reader-font-weight', String(w));
    document.querySelectorAll('article#article, #s-fontCycle').forEach(el => {
      if (el) el.style.fontWeight = w;
    });
    localStorage.setItem('mp_readerWeight', String(w));
  }
  function toggleReaderWeight() {
    const cur = parseInt(localStorage.getItem('mp_readerWeight') || '300', 10);
    const next = (cur === 300) ? 400 : 300;
    applyReaderWeight(next);
  }
  if (sWeightToggle) sWeightToggle.addEventListener('click', toggleReaderWeight);
  // Restore saved weight (default 300)
  const savedReaderWeight = parseInt(localStorage.getItem('mp_readerWeight') || '300', 10);
  applyReaderWeight(isNaN(savedReaderWeight) ? 300 : savedReaderWeight);

  // --- Sidebar open/close ---
  // Elements that control drawers/overlays. The code distinguishes mobile vs desktop
  // behavior: mobile uses slide + overlay; desktop toggles compact columns without overlay.
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('overlay');
  const menuBtn = document.getElementById('menuBtn');
  const cogBtn = document.getElementById('cogBtn');
  const settingsSidebar = document.getElementById('settingsSidebar');
  const sThemeBtn = document.getElementById('s-themeBtn');
  const isMobile = () => window.matchMedia('(max-width: 900px)').matches;

    function openSidebarMobile(){ sidebar.classList.add('open'); overlay.classList.add('show'); }
    function closeSidebarMobile(){ sidebar.classList.remove('open'); overlay.classList.remove('show'); }

  function openSettingsMobile(){ settingsSidebar.classList.add('open'); overlay.classList.add('show'); settingsSidebar.setAttribute('aria-hidden','false'); }
  function closeSettingsMobile(){ settingsSidebar.classList.remove('open'); overlay.classList.remove('show'); settingsSidebar.setAttribute('aria-hidden','true'); }

    menuBtn.addEventListener('click', () => {
      if (isMobile()) {
        // mobile: slide drawer with overlay
        sidebar.classList.contains('open') ? closeSidebarMobile() : openSidebarMobile();
      } else {
        // desktop: collapse/expand sidebar; NEVER show overlay on desktop
        document.body.classList.toggle('sidebar-collapsed');
        overlay.classList.remove('show');
      }
    });
    overlay.addEventListener('click', () => { closeSidebarMobile(); closeSettingsMobile(); });
    window.addEventListener('resize', () => { if (!isMobile()) overlay.classList.remove('show'); });

    // cog button — toggles right settings drawer (mirror of hamburger but on the right)
    if (cogBtn) {
      cogBtn.addEventListener('click', () => {
        if (isMobile()) {
          settingsSidebar.classList.contains('open') ? closeSettingsMobile() : openSettingsMobile();
        } else {
          // desktop: toggle a class to show/hide the settings column (no overlay on desktop)
          document.body.classList.toggle('settings-open');
        }
      });
    }

    // wire the small sidebar theme button to the same theme toggler
    if (sThemeBtn) {
      sThemeBtn.addEventListener('click', () => {
        setTheme((localStorage.getItem('mp_theme') || 'light') === 'light' ? 'dark' : 'light');
      });
    }

    // --- Content-width controls (readable column width) ---
    const sContentInc = document.getElementById('s-contentInc');
    const sContentDec = document.getElementById('s-contentDec');
    const sContentLabel = document.getElementById('s-contentLabel');

    function getContentWCh() {
      const raw = getComputedStyle(document.documentElement).getPropertyValue('--content-w') || '72ch';
      return parseFloat(raw);
    }
    function pxPerCh() {
      // measure 1ch in pixels reliably (accounts for current font)
      const el = document.createElement('span');
      el.style.position = 'absolute';
      el.style.visibility = 'hidden';
      el.style.width = '1ch';
      el.style.font = getComputedStyle(document.documentElement).font;
      document.body.appendChild(el);
      const w = el.getBoundingClientRect().width || el.offsetWidth || 8;
      document.body.removeChild(el);
      return w;
    }

    function viewportChAvailable() {
      const chPx = pxPerCh();
      const reader = document.querySelector('main.reader');
      let padLeft = 0, padRight = 0;
      if (reader) {
        const cs = getComputedStyle(reader);
        padLeft = parseFloat(cs.paddingLeft) || 0;
        padRight = parseFloat(cs.paddingRight) || 0;
      }
      const availablePx = Math.max(0, window.innerWidth - padLeft - padRight);
      return Math.max(1, Math.floor(availablePx / chPx));
    }

    function setContentWCh(n) {
      const clamped = Math.max(20, Math.min(n, 240)); // bounds in ch
      const avail = viewportChAvailable();
      const applied = Math.min(clamped, avail);
      document.documentElement.style.setProperty('--content-w', applied + 'ch');
      localStorage.setItem('mp_contentw', String(applied));
      if (sContentLabel) sContentLabel.textContent = applied + 'ch';
    }
    if (sContentInc) sContentInc.addEventListener('click', () => setContentWCh(getContentWCh() + 4));
    if (sContentDec) sContentDec.addEventListener('click', () => setContentWCh(getContentWCh() - 4));
    // restore saved content width
    const savedContentW = localStorage.getItem('mp_contentw');
    if (savedContentW) setContentWCh(parseFloat(savedContentW));
    else if (sContentLabel) sContentLabel.textContent = getContentWCh() + 'ch';
    // Adjust content width if viewport shrinks smaller than current setting
    window.addEventListener('resize', () => {
      try {
        const avail = viewportChAvailable();
        const current = getContentWCh();
        if (current > avail) setContentWCh(avail);
        else if (sContentLabel) sContentLabel.textContent = current + 'ch';
      } catch (e) { /* noop */ }
    });

  // --- Helpers ---
  // Short helper for querying elements and named references used below.
  const qs = (sel) => document.querySelector(sel);
  const titleEl = qs('#chapterTitle');
  const chaptersListEl = qs('#chaptersList');
  const articleEl = qs('#article');
  const scrollerEl = document.querySelector('.scroller');


    // Navigation button refs (top header and bottom nav share the same handlers)
    const navEls = {
      prevTop: qs('#prevTop'),
      nextTop: qs('#nextTop'),
      prevBottom: qs('#prevBottom'),
      nextBottom: qs('#nextBottom'),
    };

    function getParam(name) {
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }
    function setParam(name, value) {
      const url = new URL(window.location.href);
      if (value == null) url.searchParams.delete(name);
      else url.searchParams.set(name, value);
      history.pushState({}, '', url);
    }
    function normalizeId(id) {
      if (!id) return id;
      return id.endsWith('.md') ? id.slice(0, -3) : id;
    }

    // --- Load chapters index ---
    let CHAPTERS = [];        // [{ id, title }]
    let currentIndex = -1;    // index in CHAPTERS

    async function loadIndex() {
      try {
        const res = await fetch('chapters/chapters.json', { cache: 'no-cache' });
        CHAPTERS = await res.json();
      } catch (e) {
        console.error('Failed to load chapters.json', e);
        CHAPTERS = [];
      }
      renderList();
    }

    function renderList() {
      chaptersListEl.innerHTML = '';
      CHAPTERS.forEach((c, i) => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = `?chapter=${encodeURIComponent(c.id)}`;
        a.textContent = c.title || c.id;
        a.addEventListener('click', (ev) => {
          ev.preventDefault();
          openChapterByIndex(i);
          if (isMobile()) closeSidebarMobile();
        });
        li.appendChild(a);
        chaptersListEl.appendChild(li);
      });
    }

    function highlightActive() {
      const links = chaptersListEl.querySelectorAll('a');
      links.forEach((a, i) => {
        a.classList.toggle('active', i === currentIndex);
      });
    }

    async function openChapterById(id) {
      const norm = normalizeId(id);
      const index = CHAPTERS.findIndex(c => c.id === norm);
      if (index === -1 && CHAPTERS.length > 0) return openChapterByIndex(0);
      return openChapterByIndex(index);
    }

    async function openChapterByIndex(i) {
      if (i < 0 || i >= CHAPTERS.length) return;
      currentIndex = i;
      const { id, title } = CHAPTERS[i];
      titleEl.textContent = title || id;
      document.title = (title || id) + ' — Martial Peak Reader';

      // prev/next (top & bottom)
      updateNav(navEls.prevTop, i - 1);
      updateNav(navEls.nextTop, i + 1);
      updateNav(navEls.prevBottom, i - 1);
      updateNav(navEls.nextBottom, i + 1);

      setParam('chapter', id);
      highlightActive();

      try {
        const res = await fetch(`chapters/${id}.md`, { cache: 'no-cache' });
        if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
        const md = await res.text();
        articleEl.innerHTML = marked.parse(md);
        if (scrollerEl) scrollerEl.scrollTo({ top: 0, behavior: 'auto' }); // or 'smooth'
      } catch (e) {
        console.error('Failed to load chapter', id, e);
        articleEl.innerHTML = ''; // silent fail
      }
    }

  // updateNav: shows/hides a navigation control and wires it to openChapterByIndex.
  // - el: element (button or anchor)
  // - idx: index in CHAPTERS to open, or invalid index to hide the control
  function updateNav(el, idx) {
      if (idx >= 0 && idx < CHAPTERS.length) {
        el.classList.remove('hidden');
        // if it's an anchor keep href for deep-linking, otherwise attach click handler
        if (el.tagName && el.tagName.toLowerCase() === 'a') {
          el.href = `?chapter=${CHAPTERS[idx].id}`;
          el.onclick = (ev) => { ev.preventDefault(); openChapterByIndex(idx); };
        } else {
          // button or other element: set a click handler and a data-target for debugging
          el.removeAttribute('href');
          el.onclick = (ev) => { ev.preventDefault(); openChapterByIndex(idx); };
        }
      } else {
        el.classList.add('hidden');
        if (el.tagName && el.tagName.toLowerCase() === 'a') el.removeAttribute('href');
        el.onclick = null;
      }
    }

    // initial load
    (async function init() {
      await loadIndex();
      const q = getParam('chapter');
      if (q) openChapterById(q);
      else if (CHAPTERS.length > 0) openChapterByIndex(0);
    })();

    // handle browser back/forward
    window.addEventListener('popstate', () => {
      const q = getParam('chapter');
      if (q) openChapterById(q);
    });

    // Show focus outline only for keyboard navigation
    (function() {
  function handleFirstTab(e) {
    if (e.key === 'Tab') {
      document.body.classList.add('user-is-tabbing');
      window.removeEventListener('keydown', handleFirstTab);
      window.addEventListener('mousedown', handleMouseDownOnce);
      window.addEventListener('touchstart', handleMouseDownOnce);
    }
  }
  function handleMouseDownOnce() {
    document.body.classList.remove('user-is-tabbing');
    window.removeEventListener('mousedown', handleMouseDownOnce);
    window.removeEventListener('touchstart', handleMouseDownOnce);
    window.addEventListener('keydown', handleFirstTab);
  }
  window.addEventListener('keydown', handleFirstTab);
})();
  </script>
</body>
</html>
